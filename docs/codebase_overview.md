# PhotonJockey Codebase Overview

*Generated by tools/analyze_codebase.py*

## Table of Contents

1. [Package Structure](#package-structure)
2. [Main Classes](#main-classes)
3. [Class Responsibilities](#class-responsibilities)
4. [Thread Creation Points](#thread-creation-points)
5. [External Dependencies](#external-dependencies)
6. [Hot Spots](#hot-spots)

## Package Structure

The codebase contains **16 packages** with **101 classes**.

### `org.jitsi.impl.neomedia.device`

- **Classes**: 1
- **Types**: PulseAudioSystem

### `pw.wunderlich.lightbeat`

- **Classes**: 2
- **Types**: AppTaskOrchestrator, LightBeat

### `pw.wunderlich.lightbeat.audio`

- **Classes**: 9
- **Types**: AudioReader, BeatEventManager, BeatInterpreter, BeatObserver, LBAudioReader, StopStatus, is, manages, receives

### `pw.wunderlich.lightbeat.audio.device`

- **Classes**: 7
- **Types**: AudioDataListener, AudioDevice, BaseJmfAudioDevice, PullModelAudioDevice, PushModelAudioDevice, for, handles

### `pw.wunderlich.lightbeat.audio.device.provider`

- **Classes**: 12
- **Types**: CoreAudioDeviceProvider, DeviceProvider, JavaAudioDevice, JavaAudioDeviceProvider, LibJitsiDeviceProvider, PortAudioDeviceProvider, PulseAudioDeviceProvider, WASAPIDeviceProvider, WASAPILoopbackAudioDevice, for, handles, provides

### `pw.wunderlich.lightbeat.config`

- **Classes**: 4
- **Types**: Config, ConfigNode, LBConfig, allows

### `pw.wunderlich.lightbeat.gui`

- **Classes**: 2
- **Types**: FrameManager, to

### `pw.wunderlich.lightbeat.gui.frame`

- **Classes**: 7
- **Types**: AbstractFrame, ColorSelectionFrame, ConnectFrame, HueFrame, MainFrame, elements, represents

### `pw.wunderlich.lightbeat.gui.swing`

- **Classes**: 8
- **Types**: ConfigComponent, JColorPanel, JColorTile, JConfigCheckBox, JConfigSlider, JIconLabel, WrapLayout, handles

### `pw.wunderlich.lightbeat.hue.bridge`

- **Classes**: 11
- **Types**: BridgeConnection, ConnectionListener, Error, HueManager, HueStateObserver, LBHueManager, ManagerState, given, listens, manages, will

### `pw.wunderlich.lightbeat.hue.bridge.color`

- **Classes**: 6
- **Types**: Color, ColorSet, CustomColorSet, LBColor, RandomColorSet, returns

### `pw.wunderlich.lightbeat.hue.bridge.light`

- **Classes**: 7
- **Types**: LBLight, Light, LightStateBuilder, QueueEntry, UpdateQueue, represents, to

### `pw.wunderlich.lightbeat.hue.bridge.light.controller`

- **Classes**: 4
- **Types**: AbstractController, BrightnessController, ColorController, StrobeController

### `pw.wunderlich.lightbeat.hue.visualizer`

- **Classes**: 5
- **Types**: BrightnessCalibrator, BrightnessData, HueBeatObserver, LightUpdate, TransitionTimeCalibrator

### `pw.wunderlich.lightbeat.hue.visualizer.effect`

- **Classes**: 12
- **Types**: AbstractEffect, AbstractRandomEffect, AbstractThresholdEffect, AlertEffect, ColorChainEffect, ColorFadeEffect, ColorFlipEffect, ColorStrobeEffect, DefaultEffect, LightEffect, StrobeChainEffect, StrobeEffect

### `pw.wunderlich.lightbeat.util`

- **Classes**: 4
- **Types**: DoubleAverageBuffer, TimeThreshold, UpdateChecker, offering

## Main Classes

Classes with `public static void main(String[] args)` methods:

### `pw.wunderlich.lightbeat.LightBeat`

- **File**: `java/pw/wunderlich/lightbeat/LightBeat.java`
- **Description**: Entry point for application. Starts modules to bootstrap the application.

## Class Responsibilities

Key classes and their responsibilities (from Javadoc):

### Package: `org.jitsi.impl.neomedia.device`

#### `PulseAudioSystem`

Implements an <tt>AudioSystem</tt> using the native PulseAudio API/library.

### Package: `pw.wunderlich.lightbeat`

#### `AppTaskOrchestrator`

Orchestrates application-wide task execution using a combination of a scheduled executor for timed tasks and a virtual thread executor for lightweight, concurrent task handling. <p> Designed to efficiently manage I/O-bound operations, particularly those involving communication with external devices like Hue bridges, while preventing resource exhaustion through controlled concurrency limits. <p> Provides methods to dispatch immediate tasks, schedule delayed or periodic tasks, and ensures graceful shutdown of executors.

#### `LightBeat`

Entry point for application. Starts modules to bootstrap the application.

### Package: `pw.wunderlich.lightbeat.audio`

#### `BeatInterpreter`

Interprets a stream of audio amplitudes (RMS) to detect beat events. Uses a hybrid dual-threshold model to improve detection consistency. A beat must be both relatively louder than the average and a significant fraction of the last major peak's amplitude.

#### `BeatEventManager`

Implementing class manages all registered {@link BeatObserver}'s, issuing the callbacks defined in said interface.

#### `LBAudioReader`

Default {@link AudioReader} implementation that also serves as an {@link BeatEventManager}. This implementation uses a listener-based approach to process audio data as it becomes available. It can filter frequencies for bass detection and notifies registered {@link BeatObserver}s when a beat is detected.

#### `AudioReader`

Implementing class is able to return a list containing all readable audio mixers of the system, and reads audio data from a selected {@link AudioDevice}.

#### `BeatObserver`

Implementing class receives callbacks whenever a peak in the audio data was read. Additional methods {@link #noBeatReceived()} and {@link #silenceDetected()} are issued when there was no peak or there was no audible audio data anymore.

#### `StopStatus`

Status enumerator for {@link #audioReaderStopped(StopStatus)}.

### Package: `pw.wunderlich.lightbeat.audio.device`

#### `AudioDevice`

An audio device that pushes data to a registered listener. Audio devices have a {@link #getName() name} and a fixed {@link #getAudioFormat() audio format}. The user must register a listener via {@link #setAudioListener(AudioDataListener)} and then call {@link #start()} to begin receiving data.

#### `AudioDataListener`

A listener that receives audio data from a device.

#### `BaseJmfAudioDevice`

An abstract base class for JMF-based audio devices. This class handles the common device lifecycle (creation, connection, start, stop, disconnect) and leaves the specific data acquisition strategy (push vs. pull) to subclasses.

#### `PushModelAudioDevice`

An AudioDevice implementation that uses the JMF "push" model. It receives data passively via a BufferTransferHandler callback.

#### `PullModelAudioDevice`

An AudioDevice implementation that uses the JMF "pull" model. It extends the BaseJmfAudioDevice to inherit the common JMF lifecycle management.

### Package: `pw.wunderlich.lightbeat.audio.device.provider`

#### `CoreAudioDeviceProvider`

Provides {@link AudioDevice}'s for CoreAudio devices on macOS. This provider discovers all available input devices, including virtual ones like BlackHole which can be used for loopback.

#### `LibJitsiDeviceProvider`

An abstract base class for DeviceProviders that use libjitsi. This class handles the common initialization logic and provides a reusable JMF-based AudioDevice implementation.

#### `JavaAudioDeviceProvider`

Provides {@link AudioDevice}'s via Java audio API.

#### `PulseAudioDeviceProvider`

Provides {@link AudioDevice}'s for PulseAudio devices on Linux. This provider discovers both standard capture devices (microphones) and loopback devices (monitors of output sinks).

#### `WASAPIDeviceProvider`

Provides {@link AudioDevice}'s for WASAPI devices on Windows. This provider discovers both standard capture devices (microphones) and offers a special loopback capture for each playback device.

#### `DeviceProvider`

Implementing class provides implementations for {@link AudioDevice}'s.

### Package: `pw.wunderlich.lightbeat.config`

#### `LBConfig`

Configuration handler for application. Access data via various get methods. Also contains static default values if no other value is stored.

#### `Config`

Implementing class allows access to the application's configuration.

#### `ConfigNode`

Contains list of all config nodes used.

### Package: `pw.wunderlich.lightbeat.gui`

#### `FrameManager`

Manages the applications main frame, only showing one main frame at a time, which are either the connect-frame or the main application frame. Stores the current window position. Implements {@link HueStateObserver} interface to receive state callbacks and update the currently shown window accordingly.

### Package: `pw.wunderlich.lightbeat.gui.frame`

#### `HueFrame`

Implementing class represents a window frame that is disposable.

#### `ColorSelectionFrame`

Sub frame that opens a color selection GUI. Stores data via {@link Config}.

#### `MainFrame`

Main application frame. UI to set the application settings and start the magic.

#### `ConnectFrame`

Connection frame. Displays found bridges, allows manual enter and gives instructions to connect.

#### `AbstractFrame`

Abstract implementation of {@link HueFrame} that handles standard frame drawing.

### Package: `pw.wunderlich.lightbeat.gui.swing`

#### `JConfigCheckBox`

Checkbox that is dependent on a given {@link ConfigNode} boolean that may execute a runnable on change with {@link #toRunOnChange}.

#### `JIconLabel`

Label that holds multiple cached {@link Icon}'s that can be swapped with {@link #flipIcon()}.

#### `ConfigComponent`

Implementing class handles configuration related components that can be reset to a default via {@link #restoreDefault()}.

#### `JColorTile`

Colored panel that changes its borders color upon hovering.

#### `WrapLayout`

Extended FlowLayout that supports wrapping of its contents.

#### `JConfigSlider`

Slider that sets a given {@link ConfigNode} to its value whenever it changes. Allows restoring default value via {@link #restoreDefault()}.

#### `JColorPanel`

A panel that draws a color palette for hue and sat selection in its background. x-axis represents hue value, y-axis saturation (0 is highest sat value)

### Package: `pw.wunderlich.lightbeat.hue.bridge`

#### `HueManager`

Implementing class manages the current connection state to the hue bridge and passes its information to be rendered/interfaced through a {@link HueStateObserver}.

#### `BridgeConnection`

Class handling a connection to a bridge. The constructor checks if given access point is a bridge and will either initialize pushlinking or start a recurring task to check if the connection is still alive. Bridge API calls are handled asynchronously, callbacks are given through a listener implementing the {@link ConnectionListener} interface. <p> Bridge state is cached, which allows for state non-blocking state retrieval on {@link Light} objects.

#### `given`

Refreshes bridge light state in cache.

#### `listens`

Disconnect from bridge by stopping the heartbeat task. This will not trigger a call through the {@link ConnectionListener} interface given via the constructor.

#### `ConnectionListener`

Implementing class listens for connection state changes.

#### `LBHueManager`

Default {@link HueManager} implementation.

#### `HueStateObserver`

Implementing class will interpret communication received by the hue bridge to render the information to the end user and allowing interaction.

### Package: `pw.wunderlich.lightbeat.hue.bridge.color`

#### `Color`

Class represents a color.

#### `LBColor`

Default {@link Color} implementation. Contains constructors to be initialized via rgb or hue/saturation values. Handles the conversions.

#### `RandomColorSet`

Color set returning random colors with maximum saturation. Color spectrum will be accessed evenly.

#### `CustomColorSet`

Set consisting of the colors stored in {@link Config}, accessed via set name. List will pe parsed and return colors randomly upon calling {@link #getNextColor()}.

#### `ColorSet`

Implementing class returns a {@link Color} upon querying {@link #getNextColor()}.

### Package: `pw.wunderlich.lightbeat.hue.bridge.light`

#### `UpdateQueue`

Sends light updates in a synchronized queue, while waiting for callbacks from the bridge and logging received errors. Every light has its own UpdateQueue instance. <br> Will discard updates that are older than {@link #STALE_THRESHOLD_MS}. The bridge itself does not reply when an update has successfully propagated through the ZigBee network and instead only confirms the acceptance of the update. Calling {@link #addUpdate(State, boolean)} with {@code isEssential = true} will ensure the update will be sent.

#### `LightStateBuilder`

Builder class to create {@link State}'s. Can also copy from other builders via {@link #copyFromBuilder(LightStateBuilder)}.

#### `Light`

Implementing class represents a controllable light. Update its state via exposed controllers or by getting the current builder with {@link #getStateBuilder()} and send it via {@link #doLightUpdate(int)}.

#### `LBLight`

Default and thread safe {@link Light} implementation.

### Package: `pw.wunderlich.lightbeat.hue.bridge.light.controller`

#### `BrightnessController`

Controls the lights brightness and fade brightness.

#### `AbstractController`

Extending classes control certain aspects (like color control) of the light. Controllers offer the ability for {@link LightEffect}'s to reserve the control over that aspect via {@link #setControllingEffect(LightEffect)}. Manual reservations are however not necessary and depending on the implementation implied.

#### `ColorController`

Controls the lights color and fade color.

#### `StrobeController`

Controls the lights' strobing ability.

### Package: `pw.wunderlich.lightbeat.hue.visualizer`

#### `TransitionTimeCalibrator`

Dynamically calibrates the transition time used for the light fade effect for a light. Define the maxTransitionTime through the config, which will be the highest value returned by {@link #getTransitionTime(long)}. It will reach this transition time when the given time is at least twice as long as the average of previously received values (history size defined by {@link #HISTORY_SIZE}).

#### `BrightnessCalibrator`

Dynamically calibrates the brightness level after receiving amplitudes, based on the highest amplitude received. Calling {@link #getBrightness(double)} returns a {@link BrightnessData} object, which contains the relevant information for the next light update, and if a brightness change is needed in the first place. The first call to the method will always return {@link BrightnessData} that sets the brightness to 50%, and keeps sending the same amount. Brightness only changes if difference in percentage since last brightness is higher than {@link #BRIGHTNESS_CHANGE_MINIMUM_PERCENTAGE}.

#### `LightUpdate`

Stores the current beats light update information while passing through effects. Get the lights to update via {@link #getLights()} and {@link #getLightsTurnedOn()} to change their settings. The updates can then be applied via {@link #execute()}.

#### `HueBeatObserver`

Receives {@link BeatEvent}'s dispatched by the audio module. Determines brightness changes and passes the data through its effect pipe, which will then update selected lights accordingly.

### Package: `pw.wunderlich.lightbeat.hue.visualizer.effect`

#### `ColorFlipEffect`

Flips selected lights between two colors and switches colors every couple beats.

#### `AbstractRandomEffect`

Adds a random probability parameter to an effect that will only be checked if the {@link AbstractThresholdEffect} is not active at the moment.

#### `ColorStrobeEffect`

Rapidly loops through three selected colors, which update every {@link #COLOR_CHANGE_IN_MILLIS} milliseconds, for one selected and controllable light until the next beat is received.

#### `AbstractEffect`

Abstract implementation of {@link LightEffect}. Implementations must override {@link #execute(LightUpdate)} and can access the current {@link LightUpdate} via field.

#### `DefaultEffect`

Default effect that updates the color of all main lights for the current light update. It changes the color and fade color only when {@link LightUpdate#isBrightnessChange()} is true.

#### `AbstractThresholdEffect`

Adds custom brightness threshold and, if met, activation probability parameters to effects that shouldn't always be run. They will stop running once the current brightness falls below the given threshold. Will also deactivate the effect if no beat was received for a while. Calls {@link #executionDone(LightUpdate)} to allow effects to clean up.

#### `LightEffect`

Implementing classes contain custom light change effects and patterns when beats were received.

#### `ColorFadeEffect`

Sends the same fade color to all lights to cause a continuous color update fade effect. Sets the main lights to the fade color during the beat while re-selecting a new color on every beat.

#### `AlertEffect`

Adds the {@link io.github.zeroone3010.yahueapi.AlertType#SHORT_ALERT} effect to all bulbs if {@link #ALERT_THRESHOLD_MILLIS} is met. May add the effect one time randomly.

#### `StrobeChainEffect`

Turns all lights off and strobes them one by one in order. May strobe multiple lights at once, if {@link LightUpdate#getMainLights()} contains more than one light.

#### `StrobeEffect`

Effect to add a strobing, while turning all but one lights off and strobing the main lights for the current update. The strobe will be synchronized to the beat. May also randomly turn one light off and on.

#### `ColorChainEffect`

Passes one color to all lights one by one and selects a new one after all have the new color. Keeps the order of the lights and may strobe multiple lights at once, if {@link LightUpdate#getMainLights()} contains more than one light.

### Package: `pw.wunderlich.lightbeat.util`

#### `UpdateChecker`

Checks the GitHub releases API for the given repository to find the latest version. Can check if an update is available via {@link #isUpdateAvailable()}.

#### `TimeThreshold`

Helper class offering methods to compare time easily and check if a given time threshold has been passed. Can be disabled with {@link #disable()}, in which case {@link #isMet()} will always return false. Will be enabled if threshold is set with {@link #setCurrentThreshold(long)} or initialized with threshold.

#### `DoubleAverageBuffer`

Efficient ring buffer that calculates the average directly (O(1)) and can determine the max element in the buffer.

## Thread Creation Points

Locations where threads or concurrent execution is used:

### `java/pw/wunderlich/lightbeat/AppTaskOrchestrator.java`

- Line 24: ExecutorService
- Line 24: ScheduledExecutorService
- Line 25: ExecutorService

## External Dependencies

External libraries used in the project (from build.gradle):

### Runtime Dependencies

- `com.github.weisj:darklaf-core:3.1.1`
- `com.github.wendykierp:JTransforms:3.1`
- `com.jetbrains.intellij.java:java-gui-forms-rt:252.26199.158`
- `io.github.zeroone3010:yetanotherhueapi:2.8.0-lb`
- `org.jitsi:libjitsi:1.1-34-gb93ce2ee`
- `org.junit.jupiter:junit-jupiter`
- `org.junit.platform:junit-platform-launcher`
- `org.mockito:mockito-core:5.20.0`
- `org.slf4j:jul-to-slf4j:2.0.17`
- `org.slf4j:slf4j-api:2.0.17`
- `org.slf4j:slf4j-simple:2.0.17`

## Hot Spots

Potential areas of interest for optimization or careful review:

### Concurrency

- **3** threading-related code locations found across **1** files
- Review thread safety and synchronization mechanisms

### External Dependencies

- **11** external dependencies
- Review for security updates and compatibility

### Package Coupling

Packages with the most dependencies (top 5):

- `pw.wunderlich.lightbeat.gui.frame`: 9 package dependencies
- `pw.wunderlich.lightbeat.hue.visualizer`: 6 package dependencies
- `pw.wunderlich.lightbeat.audio.device.provider`: 6 package dependencies
- `pw.wunderlich.lightbeat.gui`: 5 package dependencies
- `pw.wunderlich.lightbeat.hue.visualizer.effect`: 5 package dependencies

